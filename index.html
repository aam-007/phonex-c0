<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How Transformers Work: A Visual Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1e3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #6c9fff;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #a0a0a0;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #2a2e4e;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6c9fff, #9c6fff);
            width: 0%;
            transition: width 0.5s ease;
        }

        .step-indicator {
            text-align: center;
            color: #9c6fff;
            margin-bottom: 30px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .stage {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            border: 2px solid rgba(108, 159, 255, 0.3);
            min-height: 400px;
        }

        .stage-title {
            color: #6c9fff;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-align: center;
        }

        .stage-description {
            color: #c0c0c0;
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* Text Loading Visualization */
        .text-display {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .character-box {
            background: rgba(108, 159, 255, 0.2);
            border: 2px solid #6c9fff;
            border-radius: 10px;
            padding: 15px;
            min-width: 80px;
            text-align: center;
            opacity: 0;
            transform: scale(0.5);
            animation: fadeInChar 0.5s forwards;
        }

        @keyframes fadeInChar {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .character {
            font-size: 2em;
            font-weight: bold;
            color: #6c9fff;
            margin-bottom: 5px;
        }

        .ascii-code {
            font-size: 0.9em;
            color: #a0a0a0;
        }

        /* Embedding Visualization */
        .embedding-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .embedding-vector {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .vector-label {
            font-size: 1.5em;
            color: #6c9fff;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .vector-bars {
            display: flex;
            gap: 3px;
            align-items: flex-end;
            height: 150px;
        }

        .vector-bar {
            width: 10px;
            background: linear-gradient(180deg, #6c9fff, #9c6fff);
            border-radius: 2px;
            transition: height 0.5s ease;
        }

        /* Positional Encoding */
        .position-demo {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .vector-addition {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .plus-sign {
            font-size: 3em;
            color: #9c6fff;
        }

        .equals-sign {
            font-size: 3em;
            color: #6c9fff;
        }

        /* Attention Visualization */
        .attention-display {
            position: relative;
            padding: 40px 20px;
        }

        .attention-nodes {
            display: flex;
            gap: 40px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .attention-node {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6c9fff, #9c6fff);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: white;
            font-weight: bold;
            position: relative;
            z-index: 10;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .attention-node:hover {
            transform: scale(1.1);
        }

        .attention-node.masked {
            opacity: 0.3;
        }

        .attention-arrows {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .attention-arrow {
            position: absolute;
            height: 3px;
            background: rgba(156, 111, 255, 0.6);
            transform-origin: left center;
            animation: flowArrow 1.5s ease-in-out infinite;
        }

        @keyframes flowArrow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Residual Connection */
        .residual-demo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .flow-path {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .flow-box {
            background: rgba(108, 159, 255, 0.2);
            border: 2px solid #6c9fff;
            border-radius: 10px;
            padding: 20px 30px;
            color: #6c9fff;
            font-weight: bold;
        }

        .flow-arrow {
            font-size: 2em;
            color: #9c6fff;
        }

        .bypass-arrow {
            position: relative;
            width: 200px;
            height: 80px;
        }

        .bypass-arrow svg {
            width: 100%;
            height: 100%;
        }

        /* Feed Forward */
        .feedforward-demo {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }

        .layer-viz {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .layer-label {
            color: #9c6fff;
            font-weight: bold;
        }

        .neurons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .neuron {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #6c9fff;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Softmax Prediction */
        .prediction-bars {
            width: 100%;
            max-width: 600px;
        }

        .prediction-item {
            margin-bottom: 15px;
        }

        .prediction-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #c0c0c0;
        }

        .prediction-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .prediction-fill {
            height: 100%;
            background: linear-gradient(90deg, #6c9fff, #9c6fff);
            transition: width 1s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-weight: bold;
        }

        /* Training Loop */
        .training-display {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }

        .comparison {
            display: flex;
            gap: 40px;
            font-size: 1.3em;
        }

        .comparison-item {
            text-align: center;
        }

        .comparison-label {
            color: #a0a0a0;
            margin-bottom: 10px;
        }

        .comparison-value {
            font-size: 2em;
            font-weight: bold;
        }

        .correct {
            color: #4caf50;
        }

        .incorrect {
            color: #f44336;
        }

        .loss-meter {
            width: 300px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .loss-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #f44336);
            transition: width 0.5s ease;
        }

        .loss-label {
            text-align: center;
            color: #c0c0c0;
            margin-top: 10px;
        }

        /* Model Save/Load */
        .save-load-demo {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
        }

        .model-icon {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #6c9fff, #9c6fff);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .disk-icon {
            width: 100px;
            height: 100px;
            background: #2a2e4e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            border: 4px solid #6c9fff;
        }

        .transfer-arrow {
            font-size: 3em;
            color: #9c6fff;
            animation: slide 1.5s ease-in-out infinite;
        }

        @keyframes slide {
            0%, 100% { transform: translateX(0px); }
            50% { transform: translateX(10px); }
        }

        /* Inference */
        .inference-display {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .generated-text {
            font-size: 2em;
            color: #6c9fff;
            min-height: 60px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 2px dashed #6c9fff;
        }

        .thinking-indicator {
            color: #9c6fff;
            font-style: italic;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #6c9fff, #9c6fff);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(108, 159, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #c0c0c0;
        }

        input[type="range"] {
            width: 150px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #2a2e4e;
            color: #e0e0e0;
            text-align: center;
            border-radius: 10px;
            padding: 10px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #6c9fff;
            font-size: 0.9em;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .legend {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.9em;
        }

        .legend-title {
            color: #9c6fff;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
            color: #c0c0c0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>How Transformers Work</h1>
        <p class="subtitle">A visual journey from text to prediction</p>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="step-indicator" id="stepIndicator">Step 1 of 10</div>

        <div class="stage" id="stageContainer"></div>

        <div class="controls">
            <button id="prevBtn" onclick="prevStep()">‚Üê Previous</button>
            <button id="nextBtn" onclick="nextStep()">Next ‚Üí</button>
            <button onclick="restart()">‚ü≥ Restart</button>
            <div class="speed-control">
                <label for="speedSlider">Speed:</label>
                <input type="range" id="speedSlider" min="0.5" max="2" step="0.5" value="1">
                <span id="speedValue">1x</span>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentStep = 0;
        let animationSpeed = 1;
        const totalSteps = 10;
        let activeIntervals = [];
        let activeTimeouts = [];

        // Sample text for demonstration
        const sampleText = "The";
        const vocab = "TheabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ .,!?".split('');

        // Speed control
        document.getElementById('speedSlider').addEventListener('input', function(e) {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed + 'x';
        });

        // Navigation functions
        function nextStep() {
            if (currentStep < totalSteps - 1) {
                currentStep++;
                renderStep();
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                renderStep();
            }
        }

        function restart() {
            currentStep = 0;
            renderStep();
        }

        // Clear all active animations
        function clearAllAnimations() {
            activeIntervals.forEach(interval => clearInterval(interval));
            activeTimeouts.forEach(timeout => clearTimeout(timeout));
            activeIntervals = [];
            activeTimeouts = [];
        }

        // Update progress and controls
        function updateUI() {
            const progress = ((currentStep + 1) / totalSteps) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('stepIndicator').textContent = `Step ${currentStep + 1} of ${totalSteps}`;
            
            document.getElementById('prevBtn').disabled = currentStep === 0;
            document.getElementById('nextBtn').disabled = currentStep === totalSteps - 1;
        }

        // Step 1: Loading Text
        function renderStep1() {
            return `
                <h2 class="stage-title">Step 1: Loading Text</h2>
                <p class="stage-description">
                    First, the model receives text. Each character has a numeric code (ASCII) 
                    that computers understand. Let's load our sample text: "${sampleText}"
                </p>
                <div class="visualization">
                    <div class="text-display" id="textDisplay"></div>
                </div>
                <div class="legend">
                    <div class="legend-title">What's happening:</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #6c9fff;"></div>
                        <span>Each character appears with its numeric code</span>
                    </div>
                </div>
            `;
        }

        function animateStep1() {
            const container = document.getElementById('textDisplay');
            sampleText.split('').forEach((char, i) => {
                const timeout = setTimeout(() => {
                    const box = document.createElement('div');
                    box.className = 'character-box';
                    box.style.animationDelay = '0s';
                    box.innerHTML = `
                        <div class="character">${char}</div>
                        <div class="ascii-code">‚Üí ${char.charCodeAt(0)}</div>
                    `;
                    container.appendChild(box);
                }, (i * 500) / animationSpeed);
                activeTimeouts.push(timeout);
            });
        }

        // Step 2: Embeddings
        function renderStep2() {
            return `
                <h2 class="stage-title">Step 2: Character Embeddings</h2>
                <p class="stage-description">
                    The model converts each character into a vector of numbers (16 dimensions). 
                    This is how the model "understands" characters internally.
                </p>
                <div class="visualization">
                    <div class="embedding-grid" id="embeddingGrid"></div>
                </div>
                <div class="legend">
                    <div class="legend-title">What's happening:</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(180deg, #6c9fff, #9c6fff);"></div>
                        <span>Each bar represents one dimension of the embedding (height = value)</span>
                    </div>
                </div>
            `;
        }

        function animateStep2() {
            const container = document.getElementById('embeddingGrid');
            sampleText.split('').forEach((char, charIdx) => {
                const timeout = setTimeout(() => {
                    const vectorDiv = document.createElement('div');
                    vectorDiv.className = 'embedding-vector';
                    
                    const label = document.createElement('div');
                    label.className = 'vector-label';
                    label.textContent = char;
                    
                    const bars = document.createElement('div');
                    bars.className = 'vector-bars';
                    
                    // Create 16 random bars for each character
                    for (let i = 0; i < 16; i++) {
                        const bar = document.createElement('div');
                        bar.className = 'vector-bar';
                        bar.style.height = '0px';
                        bars.appendChild(bar);
                        
                        // Animate to random height
                        const barTimeout = setTimeout(() => {
                            const height = Math.random() * 120 + 30;
                            bar.style.height = height + 'px';
                        }, (i * 50) / animationSpeed);
                        activeTimeouts.push(barTimeout);
                    }
                    
                    vectorDiv.appendChild(label);
                    vectorDiv.appendChild(bars);
                    container.appendChild(vectorDiv);
                }, (charIdx * 800) / animationSpeed);
                activeTimeouts.push(timeout);
            });
        }

        // Step 3: Positional Encoding
        function renderStep3() {
            return `
                <h2 class="stage-title">Step 3: Adding Position Information</h2>
                <p class="stage-description">
                    The same letter at different positions should mean different things. 
                    The model adds position information to each embedding.
                </p>
                <div class="visualization">
                    <div class="position-demo" id="positionDemo"></div>
                </div>
                <div class="legend">
                    <div class="legend-title">Why this matters:</div>
                    <div class="legend-item">
                        <span>The "e" in "The" (position 3) is different from "e" at position 1</span>
                    </div>
                </div>
            `;
        }

        function animateStep3() {
            const container = document.getElementById('positionDemo');
            
            const timeout = setTimeout(() => {
                // Show embedding + position = final
                const demo = document.createElement('div');
                demo.className = 'vector-addition';
                demo.innerHTML = `
                    <div class="embedding-vector">
                        <div class="vector-label">Character</div>
                        <div class="vector-bars">
                            ${Array(8).fill(0).map(() => `<div class="vector-bar" style="height: ${Math.random() * 100 + 30}px;"></div>`).join('')}
                        </div>
                    </div>
                    <span class="plus-sign">+</span>
                    <div class="embedding-vector">
                        <div class="vector-label">Position</div>
                        <div class="vector-bars">
                            ${Array(8).fill(0).map(() => `<div class="vector-bar" style="height: ${Math.random() * 100 + 30}px;"></div>`).join('')}
                        </div>
                    </div>
                    <span class="equals-sign">=</span>
                    <div class="embedding-vector">
                        <div class="vector-label">Combined</div>
                        <div class="vector-bars">
                            ${Array(8).fill(0).map(() => `<div class="vector-bar" style="height: ${Math.random() * 100 + 30}px;"></div>`).join('')}
                        </div>
                    </div>
                `;
                container.appendChild(demo);
            }, 300 / animationSpeed);
            activeTimeouts.push(timeout);
        }

        // Step 4: Self-Attention
        function renderStep4() {
            return `
                <h2 class="stage-title">Step 4: Self-Attention (The Magic!)</h2>
                <p class="stage-description">
                    Each character "pays attention" to previous characters to understand context. 
                    Hover over a node to see what it's looking at!
                </p>
                <div class="visualization">
                    <div class="attention-display" id="attentionDisplay">
                        <div class="attention-nodes" id="attentionNodes"></div>
                        <svg class="attention-arrows" id="attentionArrows" width="100%" height="200"></svg>
                    </div>
                </div>
                <div class="legend">
                    <div class="legend-title">What's happening:</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(156, 111, 255, 0.6);"></div>
                        <span>Arrows show attention flow (thicker = stronger attention)</span>
                    </div>
                    <div class="legend-item">
                        <span>üîí Faded characters are masked (can't see the future!)</span>
                    </div>
                </div>
            `;
        }

        function animateStep4() {
            const nodesContainer = document.getElementById('attentionNodes');
            const svg = document.getElementById('attentionArrows');
            const chars = sampleText.split('');
            
            // Create nodes
            chars.forEach((char, i) => {
                const timeout = setTimeout(() => {
                    const node = document.createElement('div');
                    node.className = 'attention-node';
                    node.textContent = char;
                    node.dataset.index = i;
                    
                    // Mask future tokens
                    if (i > 1) {
                        node.classList.add('masked');
                    }
                    
                    nodesContainer.appendChild(node);
                    
                    // Draw attention arrows after all nodes are placed
                    if (i === chars.length - 1) {
                        const drawTimeout = setTimeout(() => drawAttentionArrows(), 500 / animationSpeed);
                        activeTimeouts.push(drawTimeout);
                    }
                }, (i * 400) / animationSpeed);
                activeTimeouts.push(timeout);
            });
        }

        function drawAttentionArrows() {
            const nodes = document.querySelectorAll('.attention-node');
            const svg = document.getElementById('attentionArrows');
            
            nodes.forEach((toNode, toIdx) => {
                // Each node attends to all previous nodes
                for (let fromIdx = 0; fromIdx <= toIdx; fromIdx++) {
                    if (toIdx === fromIdx) continue;
                    
                    const fromNode = nodes[fromIdx];
                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const svgRect = svg.getBoundingClientRect();
                    
                    const x1 = fromRect.left + fromRect.width / 2 - svgRect.left;
                    const y1 = fromRect.top + fromRect.height / 2 - svgRect.top;
                    const x2 = toRect.left + toRect.width / 2 - svgRect.left;
                    const y2 = toRect.top + toRect.height / 2 - svgRect.top;
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(156, 111, 255, 0.6)');
                    line.setAttribute('stroke-width', Math.random() * 3 + 1);
                    line.style.animation = 'flowArrow 1.5s ease-in-out infinite';
                    
                    svg.appendChild(line);
                }
            });
        }

        // Step 5: Residual Connections
        function renderStep5() {
            return `
                <h2 class="stage-title">Step 5: Residual Connections</h2>
                <p class="stage-description">
                    Don't forget the original information! The model adds a "bypass" route 
                    so the original embeddings aren't lost.
                </p>
                <div class="visualization">
                    <div class="residual-demo">
                        <div class="flow-path">
                            <div class="flow-box">Input</div>
                            <span class="flow-arrow">‚Üí</span>
                            <div class="flow-box">Attention</div>
                            <span class="flow-arrow">‚Üí</span>
                            <div class="flow-box">Output</div>
                        </div>
                        <div style="margin: 20px 0; color: #9c6fff; font-size: 1.2em;">+ (Bypass Connection) ‚Üì</div>
                        <div class="flow-path">
                            <div class="flow-box">Input</div>
                            <span class="flow-arrow">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí</span>
                            <div class="flow-box">Added Back</div>
                        </div>
                    </div>
                </div>
                <div class="legend">
                    <div class="legend-title">Why this matters:</div>
                    <div class="legend-item">
                        <span>Helps the model learn better by keeping original information</span>
                    </div>
                </div>
            `;
        }

        function animateStep5() {
            // Static visualization, no animation needed
        }

        // Step 6: Feed-Forward Network
        function renderStep6() {
            return `
                <h2 class="stage-title">Step 6: Feed-Forward "Thinking"</h2>
                <p class="stage-description">
                    After attention, each position goes through a small neural network. 
                    Think of it as the model "thinking" about what it just learned.
                </p>
                <div class="visualization">
                    <div class="feedforward-demo">
                        <div class="layer-viz">
                            <div class="layer-label">Input (16)</div>
                            <div class="neurons">
                                ${Array(8).fill(0).map(() => '<div class="neuron"></div>').join('')}
                            </div>
                        </div>
                        <span class="flow-arrow">‚Üí</span>
                        <div class="layer-viz">
                            <div class="layer-label">Hidden (32)</div>
                            <div class="neurons">
                                ${Array(16).fill(0).map(() => '<div class="neuron"></div>').join('')}
                            </div>
                        </div>
                        <span class="flow-arrow">‚Üí</span>
                        <div class="layer-viz">
                            <div class="layer-label">Output (16)</div>
                            <div class="neurons">
                                ${Array(8).fill(0).map(() => '<div class="neuron"></div>').join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="legend">
                    <div class="legend-title">What's happening:</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #6c9fff; border-radius: 50%;"></div>
                        <span>Each dot is a "neuron" ‚Äî pulsing shows activity</span>
                    </div>
                </div>
            `;
        }

        function animateStep6() {
            // Animation handled by CSS
        }

        // Step 7: Softmax Prediction
        function renderStep7() {
            return `
                <h2 class="stage-title">Step 7: Predicting the Next Character</h2>
                <p class="stage-description">
                    The model outputs probabilities for what comes next. 
                    After "The", it might predict a space " " or other characters.
                </p>
                <div class="visualization">
                    <div class="prediction-bars" id="predictionBars"></div>
                </div>
                <div class="legend">
                    <div class="legend-title">Understanding the bars:</div>
                    <div class="legend-item">
                        <span>Bar length = probability (all bars add up to 100%)</span>
                    </div>
                </div>
            `;
        }

        function animateStep7() {
            const container = document.getElementById('predictionBars');
            const predictions = [
                { char: '" " (space)', prob: 45 },
                { char: 'r', prob: 15 },
                { char: 'y', prob: 12 },
                { char: 'n', prob: 10 },
                { char: 'm', prob: 8 },
                { char: 'other', prob: 10 }
            ];
            
            predictions.forEach((pred, i) => {
                const timeout = setTimeout(() => {
                    const item = document.createElement('div');
                    item.className = 'prediction-item';
                    item.innerHTML = `
                        <div class="prediction-label">
                            <span>${pred.char}</span>
                            <span>${pred.prob}%</span>
                        </div>
                        <div class="prediction-bar">
                            <div class="prediction-fill" style="width: 0%;" data-width="${pred.prob}"></div>
                        </div>
                    `;
                    container.appendChild(item);
                    
                    // Animate bar
                    const barTimeout = setTimeout(() => {
                        const fill = item.querySelector('.prediction-fill');
                        if (fill) {
                            fill.style.width = fill.dataset.width + '%';
                        }
                    }, 100);
                    activeTimeouts.push(barTimeout);
                }, (i * 300) / animationSpeed);
                activeTimeouts.push(timeout);
            });
        }

        // Step 8: Training
        function renderStep8() {
            return `
                <h2 class="stage-title">Step 8: Learning from Mistakes</h2>
                <p class="stage-description">
                    The model compares its prediction to the actual next character. 
                    If it's wrong, it adjusts its internal numbers (weights) to do better next time.
                </p>
                <div class="visualization">
                    <div class="training-display" id="trainingDisplay"></div>
                </div>
                <div class="legend">
                    <div class="legend-title">The learning process:</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>Green = correct prediction ‚Üí small adjustment</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f44336;"></div>
                        <span>Red = wrong prediction ‚Üí bigger adjustment</span>
                    </div>
                </div>
            `;
        }

        function animateStep8() {
            const container = document.getElementById('trainingDisplay');
            
            // Show comparison
            const comparison = document.createElement('div');
            comparison.className = 'comparison';
            comparison.innerHTML = `
                <div class="comparison-item">
                    <div class="comparison-label">Model Predicted:</div>
                    <div class="comparison-value incorrect">" "</div>
                </div>
                <div class="comparison-item">
                    <div class="comparison-label">Actual Next:</div>
                    <div class="comparison-value correct">" "</div>
                </div>
            `;
            container.appendChild(comparison);
            
            // Show loss meter
            const timeout = setTimeout(() => {
                const lossDiv = document.createElement('div');
                lossDiv.innerHTML = `
                    <div style="text-align: center; margin-bottom: 10px; color: #c0c0c0;">
                        Loss (Error) Meter
                    </div>
                    <div class="loss-meter">
                        <div class="loss-fill" id="lossFill" style="width: 80%;"></div>
                    </div>
                    <div class="loss-label">Training... adjusting weights ‚öôÔ∏è</div>
                `;
                container.appendChild(lossDiv);
                
                // Animate loss decreasing
                let loss = 80;
                const interval = setInterval(() => {
                    loss -= 5;
                    const lossFill = document.getElementById('lossFill');
                    if (lossFill) {
                        lossFill.style.width = loss + '%';
                    }
                    if (loss <= 20) {
                        clearInterval(interval);
                        const lossLabel = document.querySelector('.loss-label');
                        if (lossLabel) {
                            lossLabel.textContent = 'Better! ‚úì';
                        }
                    }
                }, (500 / animationSpeed));
                activeIntervals.push(interval);
            }, 1000 / animationSpeed);
            activeTimeouts.push(timeout);
        }

        // Step 9: Saving the Model
        function renderStep9() {
            return `
                <h2 class="stage-title">Step 9: Saving the Model</h2>
                <p class="stage-description">
                    After training, all those adjusted numbers (weights) are saved to disk. 
                    This way, the model remembers what it learned!
                </p>
                <div class="visualization">
                    <div class="save-load-demo">
                        <div class="model-icon">üß†</div>
                        <div class="transfer-arrow">‚Üí</div>
                        <div class="disk-icon">üíæ</div>
                    </div>
                    <div style="text-align: center; margin-top: 20px; color: #9c6fff; font-size: 1.2em;">
                        Model saved! All learned patterns are preserved.
                    </div>
                </div>
                <div class="legend">
                    <div class="legend-title">What gets saved:</div>
                    <div class="legend-item">
                        <span>üìä All embedding weights</span>
                    </div>
                    <div class="legend-item">
                        <span>üîó All attention patterns</span>
                    </div>
                    <div class="legend-item">
                        <span>üßÆ All feed-forward weights</span>
                    </div>
                </div>
            `;
        }

        function animateStep9() {
            // Animation handled by CSS
        }

        // Step 10: Inference
        function renderStep10() {
            return `
                <h2 class="stage-title">Step 10: Generating Text!</h2>
                <p class="stage-description">
                    Now the model can predict new text! It starts with a prompt and 
                    generates one character at a time, using what it learned.
                </p>
                <div class="visualization">
                    <div class="inference-display">
                        <div>Starting prompt: <strong>"The"</strong></div>
                        <div class="generated-text" id="generatedText">The</div>
                        <div class="thinking-indicator" id="thinkingIndicator">Thinking...</div>
                    </div>
                </div>
                <div class="legend">
                    <div class="legend-title">How it works:</div>
                    <div class="legend-item">
                        <span>1. Start with prompt ‚Üí 2. Predict next character ‚Üí 3. Add to text ‚Üí 4. Repeat!</span>
                    </div>
                </div>
            `;
        }

        function animateStep10() {
            const textEl = document.getElementById('generatedText');
            const thinkingEl = document.getElementById('thinkingIndicator');
            const toGenerate = " cat sat";
            let currentText = "The";
            let i = 0;
            
            const generateInterval = setInterval(() => {
                if (i < toGenerate.length) {
                    thinkingEl.textContent = 'Predicting...';
                    const timeout = setTimeout(() => {
                        currentText += toGenerate[i];
                        textEl.textContent = currentText;
                        thinkingEl.textContent = 'Added: "' + toGenerate[i] + '"';
                        i++;
                    }, 500 / animationSpeed);
                    activeTimeouts.push(timeout);
                } else {
                    thinkingEl.textContent = '‚úì Complete!';
                    clearInterval(generateInterval);
                }
            }, 1500 / animationSpeed);
            activeIntervals.push(generateInterval);
        }

        // Main render function
        function renderStep() {
            clearAllAnimations();
            updateUI();
            
            const steps = [
                { render: renderStep1, animate: animateStep1 },
                { render: renderStep2, animate: animateStep2 },
                { render: renderStep3, animate: animateStep3 },
                { render: renderStep4, animate: animateStep4 },
                { render: renderStep5, animate: animateStep5 },
                { render: renderStep6, animate: animateStep6 },
                { render: renderStep7, animate: animateStep7 },
                { render: renderStep8, animate: animateStep8 },
                { render: renderStep9, animate: animateStep9 },
                { render: renderStep10, animate: animateStep10 }
            ];
            
            const container = document.getElementById('stageContainer');
            container.innerHTML = steps[currentStep].render();
            
            // Start animation after render
            const timeout = setTimeout(() => {
                steps[currentStep].animate();
            }, 100);
            activeTimeouts.push(timeout);
        }

        // Initialize
        renderStep();
    </script>
</body>
</html>